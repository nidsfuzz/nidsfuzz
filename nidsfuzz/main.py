import argparse
import asyncio
import sys

from Fuzzer import Fuzzer
from Replayer import Replayer
from injection import TunableResponder
from logger import setup_logger
from rule import Proto


def main():
    parser = argparse.ArgumentParser(
        description='An interface to start the frontend or backend of the nidsfuzz.',
        formatter_class=argparse.RawTextHelpFormatter
    )
    parent_parser = argparse.ArgumentParser(add_help=False)
    parent_parser.add_argument('--tuning-port', type=int, help='The port of tuning service.')
    parent_parser.add_argument('--tuned-port', type=int, help='The port of tuned service.')
    parent_parser.add_argument('--log-path', type=str, help='The path of the log file.')

    subparsers = parser.add_subparsers(dest='command', required=True)

    ########################################
    fuzzing_parser = subparsers.add_parser('fuzzing', parents=[parent_parser])
    fuzzing_parser.add_argument(
        '--client',
        type=str,
        help='The address of the tunable initiator.'
    )
    fuzzing_parser.add_argument(
        '--server',
        type=str,
        help='The address of the tunable responder.'
    )
    fuzzing_parser.add_argument(
        "--output",
        type=str,
        help="The output directory to save the fuzzing results."
    )
    fuzzing_parser.add_argument(
        '--rule-files',
        type=str,
        nargs='+',
        help='The rule files under testing.',
    )
    fuzzing_parser.add_argument(
        '--alert-files',
        type=str,
        nargs='+',
        help='The alert files generated by each evaluated NIDS platform.'
    )
    fuzzing_parser.add_argument(
        "--protocol",
        type=str,
        default=None,
        help='The target protocol to test.'
    )
    fuzzing_parser.add_argument(
        '--selection',
        choices=['sequential', 'random', 'combination'],
        default='random',
        help='The rule selecting algorithm to use.')
    fuzzing_parser.add_argument(
        "--batch-size",
        type=int,
        default=1,
        help='The number of rules to test in each batch.'
    )
    fuzzing_parser.add_argument(
        "--batch-num",
        type=int,
        default=100000,
        help='The number of batches generated in the fuzzing activity.'
    )
    fuzzing_parser.add_argument(
        '--generation',
        choices=['pass-through', 'blending', 'obfuscation', 'repetition'],
        default='pass-through',
        help='The rule mutating algorithm to use.'
    )
    fuzzing_parser.add_argument(
        "--repeat-mode",
        choices=['block-wise', 'element-wise'],
        default='block-wise',
        help='The repetition mode to use.'
    )
    fuzzing_parser.add_argument(
        '--threshold',
        type=int,
        default=1,
        help='The threshold of the accumulation analyzer.'
    )
    fuzzing_parser.set_defaults(func=fuzzing)

    ########################################
    replay_parser = subparsers.add_parser('replay', parents=[parent_parser])
    replay_parser.add_argument(
        '--client',
        type=str,
        help='The address of the tunable initiator.'
    )
    replay_parser.add_argument(
        '--server',
        type=str,
        help='The address of the tunable responder.'
    )
    replay_parser.add_argument(
        "--input",
        type=str,
        help="The input directory to the replayed packets."
    )
    replay_parser.set_defaults(func=replay)

    ########################################
    server_parser = subparsers.add_parser('server', parents=[parent_parser])
    server_parser.set_defaults(func=server)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    args.func(args)

def fuzzing(args):
    if args.protocol not in Proto.all():
        protocol = None
    else:
        protocol = args.protocol

    if args.log_path is not None:
        setup_logger(args.log_path)

    fuzzer = Fuzzer(
        initiator_addr=args.client,
        responder_addr=args.server,
        tuning_port=args.tuning_port,
        tuned_port=args.tuned_port,
        output_dir=args.output,
        proto=protocol,
    ).setup_selection(
        rule_files=args.rule_files,
        algorithm=args.selection,
        batch_size=args.batch_size,
        batch_num=args.batch_num,
    ).setup_generation(
        algorithm=args.generation,
        mode=args.repeat_mode,
    ).setup_sanitization(
        alert_files=args.alert_files,
    ).setup_adaptation(
        threshold=args.threshold,
    )

    fuzzer.start()

    try:
        fuzzer.join()
    except KeyboardInterrupt:
        fuzzer.stop()
        fuzzer.join()

def replay(args):
    if args.log_path is not None:
        setup_logger(args.log_path)

    replayer = Replayer(
        initiator_addr=args.client,
        responder_addr=args.server,
        tuning_port=args.tuning_port,
        tuned_port=args.tuned_port,
        input_dir=args.input,
    )

    replayer.start()

def server(args):
    if args.log_path is not None:
        setup_logger(args.log_path)

    tunable_server = TunableResponder(
        tuning_listen_addr=("0.0.0.0", args.tuning_port),
        tuned_listen_addr=("0.0.0.0", args.tuned_port),
    )

    asyncio.run(tunable_server.start())


if __name__ == '__main__':
    main()