import threading
import re
import threading
import time
from collections import deque, Counter
from queue import Queue

import logger


class AlertSanitizer:
    """
    Alert Sanitization consists of 2 sub-functions:
        1. monitoring the alert files which are written by each NIDS.
        2. validating test cases and corresponding generated alerts.

    This module outputs the abnormal alerts, which appear in the alert files
    produced by some NIDS, but are absent in others.
    """
    ALERT_PATTERN = (r'^.*? \[\*\*] \[(?P<rule_id>\d+:\d+:\d+)] .*? \[\*\*] \[Classification.*?] \[Priority.*?] \{.*?} '
                     r'(?P<src_ip>\d+\.\d+\.\d+.\d+):(?P<src_port>\d+) -> (?P<dst_ip>\d+\.\d+\.\d+.\d+):('
                     r'?P<dst_port>\d+)')

    def __init__(self,
                 test_queue: Queue[tuple[str, tuple[str, int], tuple[str, int], bytes, bytes]],
                 sanitized_test_queue: Queue[tuple],
                 alert_files: list[str],
                 timeout=0.5,
                 n_tests: int = 25,
                 ):
        super().__init__()
        self.test_queue = test_queue
        self.sanitized_test_queue = sanitized_test_queue
        # Define some buffers to store the alerts generated by each NIDS.
        self.alert_caches = {alert_file: deque() for alert_file in alert_files}
        # Monitoring timeout
        self.timeout = timeout
        # Validating when the number of test cases reaches n_tests.
        self.n_tests = n_tests

        # The pattern used to capture alert texts.
        self._pattern = re.compile(self.ALERT_PATTERN)

        # Alert monitor thread related variables
        self._exit = threading.Event()
        self._monitoring = threading.Event()
        self._monitoring.set()
        self._alert_monitors = {
            alert_file: threading.Thread(target=self.monitor, args=(alert_file, alert_deque,)) for
            alert_file, alert_deque in self.alert_caches.items()}
        for _, t in self._alert_monitors.items():
            t.start()

    @property
    def alert_files(self) -> list[str]:
        return list(self.alert_caches.keys())

    ###############################################################################

    def validate(self, port_window: list[int]):
        self._pause()
        if self.test_queue.qsize() >= self.n_tests:
            while self.test_queue.qsize() > 5:
                rule_id, initiator, responder, request, response = self.test_queue.get()
                logger.debug(f'validating test case: {rule_id}, endpoints: {initiator}, {responder}')
                # Align the generated alerts with the test case.
                aligned_alerts = self._align(initiator, responder, port_window=port_window)
                if self._compare(aligned_alerts):
                    logger.debug(f'all targets generated the same alerts for the test case: {rule_id}')
                    continue
                logger.success(f'found inconsistencies in alerts reacting to the test case: {rule_id}')
                self.sanitized_test_queue.put((rule_id, initiator, responder, request, response, aligned_alerts))
        self._resume()

    def _align(self, initiator: tuple[str, int], responder: tuple[str, int], port_window: list[int]) -> dict[
        str, list[tuple]]:
        result = {alert_file: list() for alert_file in self.alert_files}
        for alert_file, alert_deque in self.alert_caches.items():
            logger.debug(f'aligning alert file {alert_file}')
            while True:
                if len(alert_deque) <= 0:
                    logger.debug(f'no more alerts in {alert_file}')
                    break
                rule_id, src_ip, src_port, dst_ip, dst_port = alert_deque[0]

                # determine traffic direction

                if responder == (src_ip, int(src_port)):
                    client = (dst_ip, int(dst_port))
                    server = (src_ip, int(src_port))
                elif responder == (dst_ip, int(dst_port)):
                    client = (src_ip, int(src_port))
                    server = (dst_ip, int(dst_port))
                else:
                    logger.error(f'illegal traffic direction: {(src_ip, int(src_port))} --> {(dst_ip, int(dst_port))}')
                    raise RuntimeError(
                        f'illegal traffic direction: {(src_ip, int(src_port))} --> {(dst_ip, int(dst_port))}')

                # determine the corresponding alerts triggered by this test traffic

                if {initiator, responder} == {client, server}:
                    result[alert_file].append(alert_deque.popleft())
                    logger.debug(f'found a matched port: alert {rule_id}')
                    continue
                elif client[1] not in port_window:
                    logger.debug(
                        f'found a port {client[1]} that is not recently used. It may be a delayed alert, we ignore this alert: {rule_id}')
                    alert_deque.popleft()
                    continue
                else:
                    logger.debug(f'found a mismatched port, finishing alignment for {alert_file}')
                    break

        return result

    def _compare(self, alignment: dict[str, list[tuple]]):
        counters = [Counter(alert_list) for alert_list in alignment.values()]
        # compare the number of alerts and the rule_id of each alert
        is_equal = all(counter == counters[0] for counter in counters)
        return is_equal

    ###############################################################################

    def monitor(self, alert_file: str, alert_deque: deque):
        retry = 5
        while True:
            start_time = time.time()
            try:
                with open(alert_file, 'r') as f:
                    while not self._exit.is_set():
                        self._monitoring.wait()
                        while True:
                            line = f.readline()
                            if line:
                                logger.debug(f'monitoring {alert_file} line: {line}')
                                alert = self._match(line)
                                if alert:
                                    # Found an alert and append it into the deque
                                    alert_deque.append(alert)
                                    logger.debug(f'found an alert {alert}')
                                start_time = time.time()
                            else:
                                # If no data is read within the timeout, then re-check flags.
                                elapsed = time.time() - start_time
                                if elapsed > self.timeout:
                                    logger.debug(f'timeout {elapsed} when monitoring {alert_file}')
                                    break
                                time.sleep(0.1)
            except FileNotFoundError:
                time.sleep(1)
                retry = retry - 1
                if retry == 0:
                    logger.critical(f'file not found: {alert_file}')
                    break
            else:
                logger.debug(f'exited monitor: {alert_file}')
                break

    def _match(self, line):
        line = line.strip()
        match = re.match(self._pattern, line)
        if match:
            return match.groups()
        return None

    def _pause(self):
        self._monitoring.clear()
        time.sleep(0.1)

    def _resume(self):
        self._monitoring.set()

    ###############################################################################

    def exit(self):
        self._exit.set()
        self._monitoring.set()

        for alert_file, t in self._alert_monitors.items():
            logger.debug(f'waiting for monitoring to finish: {alert_file}')
            t.join()
